###This file is supposed to conatain the module for the pre-processo
#using CairoMakie
using GLMakie
using NearestNeighbors

module Blocks #Coordinates of a base block x,y
    # export Cartesian, Tetraheder
    Cartesian = [(x,y) for x = 0:1, y = 0:1]
    Cartesian = [Cartesian[i] for i = eachindex(Cartesian)]
    transmission_line_length = Dict("Cartesian"=>(1))
    crystal = Dict("Cartesian"=>Cartesian)
    no_branches = Dict("Cartesian"=>4) #number of branches on each node
end

module Generator
    using NearestNeighbors: KDTree, inrange
    using StaticArrays
    using ProgressBars
    import ..Blocks
    #Multithreading the process of multiplying the blocks?
    #Finding the neigbours by checkings what nodes are within a set radius
    mutable struct Node     #The node
        x::Float64 #Coordinates of the node
        y::Float64
        neighbours::Vector{Int64}
        inbound::Vector{Float64} #The indexes of the vectors correspond to the neighbours indexes
        outbound::Vector{Float64}
        on_node::Float64
    end;
    function scale_crystal(crystal::Vector{Tuple{Int64, Int64}}, scale::Float64)
        return [(scale*crystal[i][1], scale*crystal[i][2]) for i = eachindex(crystal)]
    end
    
    function nodes(dimensions::Tuple{Float64, Float64}; crystal::String = "Cartesian", transmission_line_length::Float64 = 1.0)
        #The largest possible rectangle within the chosen dimensions will be generated
        scale = transmission_line_length/Blocks.transmission_line_length[crystal]
        transmission_line_length = scale*Blocks.transmission_line_length[crystal]
        no_branches = Blocks.no_branches[crystal]
        crystal = scale_crystal(Blocks.crystal[crystal], scale)
        coordinates = Set()
        crystal_size = findmax(crystal[findmax(crystal)[2]])[1]
        accuracy = 14
        iter = ProgressBar(1:ceil(dimensions[1]/crystal_size))
        for x = iter
            for y = 1:ceil(dimensions[2]/crystal_size)
                for i = eachindex(crystal)
                    #Accuracy is reduced to mitigate rounding errors, earlier prints showed an original accuracy of 17 digits
                    push!(coordinates, (round(crystal[i][1]+(x-1)*crystal_size + transmission_line_length/2, sigdigits=accuracy), 
                                        round(crystal[i][2]+(y-1)*crystal_size + transmission_line_length/2, sigdigits=accuracy)))
                end
            end
            set_description(iter, "Generating node coordinates: ")
        end
        pbar = ProgressBar(total = length(coordinates))
        for coord in coordinates
            if coord[1] > dimensions[1] || coord[2] > dimensions[2]
                pop!(coordinates, coord)
            end
            update(pbar)
            set_description(pbar, "Filtering coordinate duplicates: ")
        end
        nodes = Dict()
        println("Restructuring coordinates")
        #Trying 2d, if not z must be set to the same integer everywhere, then everything is in the same plane
        data::Vector{SVector{2, Float64}} = [[coord[1], coord[2]] for coord in coordinates]
        pbar = ProgressBar(total = length(coordinates))
        for (i, coord) in enumerate(coordinates)
            nodes[i] = Node(coord[1], coord[2], zeros(Int64, no_branches), zeros(no_branches), zeros(no_branches), 0.0)
            update(pbar)
            set_description(pbar, "Generating nodes: ")
        end
        #The indexes of the nodes in the KDTree are the same as the indexes of the coordinates in the data vector
        kdtree = KDTree(data)
        pbar = ProgressBar(total = length(nodes))
        for key in keys(nodes) #0.01 margin added to the transmission line length to make up for rounding errors
            neighbours = [index for index in inrange(kdtree, data[key], transmission_line_length*1.01)]
            nodes[key].neighbours = filter!(v->v!=key, neighbours)
            update(pbar)
            set_description(pbar, "Finding node neighbours: ")
        end
        pbar = ProgressBar(total = length(nodes))
        for key in keys(nodes)
            if length(nodes[key].neighbours) > no_branches
                display(nodes[key])
                throw(ErrorException("The number of neighbours is larger than the number of branches, adjusting the rounding in lines 52-54 might help, current: "*string(accuracy)))
            end
            if length(nodes[key].neighbours) < no_branches
                for i = (length(nodes[key].neighbours)+1):no_branches
                    #uses 0 as placeholders to create the correct number of branches where neighbours are missing
                    push!(nodes[key].neighbours, 0)
                end
            end
            update(pbar)
            set_description(pbar, "Filling boundaries into nodes: ")
        end
        return nodes, kdtree
    end
end

module Solver
include("mesh-generator.jl")
    sine_sources::Vector{Any} = [] #[[node_index, amplitude, frequency, periods]]
    dirac_sources::Vector{Any} = [] #[[node_index, amplitude]]
    chirp_sources::Vector{Any} = [] #[[node_index, amplitude, frequency, periods]]
    source_outputs::Vector{Any} = [[],[],[]] #[[[(timestamp, amplitude)...]],[[[(timestamp, amplitude)]...]]
    using NearestNeighbors
    using StaticArrays
    using ChirpSignal
    function generate_sine(nodes, position, kdtree = nothing; amplitude = 1, frequency = 1, periods = Inf)
        if kdtree === nothing
            sorted_keys = sort([node[1] for node in nodes])
            kdtree = KDTree([SVector{2, Float64}(nodes[key].x, nodes[key].y) for key in sorted_keys])
        end
        indexes, distances = knn(kdtree, [position[1], position[2]], 1, true)
        #println("Position: "*string(position)*" Indexes: "*string(indexes)*" Distances: "*string(distances))
        push!(sine_sources, [indexes[1], amplitude, frequency, periods])
        push!(source_outputs[1], [])
    end
    function generate_dirac(nodes, position, kdtree = nothing; amplitude = 1)
        if kdtree === nothing
            sorted_keys = sort([node[1] for node in nodes])
            kdtree = KDTree([SVector{2, Float64}(nodes[key].x, nodes[key].y) for key in sorted_keys])
        end
        indexes, distances = knn(kdtree, [position[1], position[2]], 1, true)
        println("Position: "*string(position)*" Indexes: "*string(indexes)*" Distances: "*string(distances))
        push!(dirac_sources, [indexes[1], amplitude])
        push!(source_outputs[2], [])
    end

    function generate_chirp(nodes, position, fs, f1, fh, T, kdtree = nothing; amplitude = 1, method = "logarithmic")
        if kdtree === nothing
            sorted_keys = sort([node[1] for node in nodes])
            kdtree = KDTree([SVector{2, Float64}(nodes[key].x, nodes[key].y) for key in sorted_keys])
        end
        indexes, distances = knn(kdtree, [position[1], position[2]], 1, true)
        #println("Position: "*string(position)*" Indexes: "*string(indexes)*" Distances: "*string(distances))
        push!(chirp_sources, [indexes[1], fs, T, chirp(T, fs, fl, fh; method = method)])
        push!(source_outputs[3], [])
    end

    function inbound!(nodes; reflection_factor = 1.0)
        for key in keys(nodes)
            pressures = []
            for (index, neighbour) in enumerate(nodes[key].neighbours)
                if neighbour != 0
                    push!(pressures, nodes[neighbour].outbound[findfirst(isequal(key), nodes[neighbour].neighbours)])
                elseif neighbour == 0
                    push!(pressures, nodes[key].outbound[index]*reflection_factor)
                end
            end
            nodes[key].inbound = pressures
        end
    end
    function on_node!(nodes, timestamp)
        no_branches = length(nodes[1].neighbours)
        for key in keys(nodes)
            nodes[key].on_node = 2/no_branches*sum(nodes[key].inbound)
        end
        for (i, source) in enumerate(sine_sources)
            source[4] != Inf ? (timestamp > source[4]*source[3]^-1 ? continue : nothing) : nothing
            output = source[2]*sin(2*pi*source[3]*timestamp)
            nodes[source[1]].on_node += output
            push!(source_outputs[1][i],[timestamp, output])
        end
        timestamp != 0 ? nothing : for (i, source) in enumerate(dirac_sources)
            nodes[source[1]].on_node += source[2]
            push!(source_outputs[2][i],[timestamp, source[2]])
            println("Iteration 0 run")
        end
        for (i, source) in enumerate(chirp_sources)
            if timestamp <= source[3]
                output = source[4][Int(round(timestamp*source[2]))+1] #+1 as the first timestamp is expected to be 0
                nodes[source[1]].on_node += output
                push!(source_outputs[3][i],[timestamp, output])
            end
        end
    end
    function outbound!(nodes)
        for key in keys(nodes)
            nodes[key].outbound = [nodes[key].on_node - inbound for inbound in nodes[key].inbound]
        end
    end
    function update_tlm!(nodes, timestamp; reflection_factor = 1.0)
        inbound!(nodes, reflection_factor = reflection_factor)
        on_node!(nodes, timestamp)
        outbound!(nodes)
    end
end

n, tree = Generator.nodes((600.0,200.0), crystal = "Cartesian", transmission_line_length = 1.0)

function find_nearest_node(tree, position)
    indexes, distances = knn(tree, position, 1, true)
    return indexes[1]
end

n_followed = 10
followed_nodes = [Int(find_nearest_node(tree, [199.5+12*i, 99.5])) for i in 0:n_followed-1]
#inbounds = [[] for i in 1:length(followed_nodes)]
on_nodes = [[] for i in 1:length(followed_nodes)]
#outbounds = [[] for i in 1:length(followed_nodes)]

iterations = 450
for i in 0:iterations
    timestamp = i/20
    Solver.inbound!(n, reflection_factor = 0)
    Solver.on_node!(n, timestamp)
    i <= 60 ? n[followed_nodes[1]].on_node += sin(2*pi*timestamp) : nothing
    Solver.outbound!(n)
    #i <= 120 ? n[followed_nodes[1]].outbound[4] += sin(2*pi*timestamp) : nothing
    #i <= 60 ? n[followed_nodes[1]].outbound .+= sin(2*pi*timestamp) : nothing
    #i <= 0 ? n[followed_nodes[1]].outbound .+= 1 : nothing
    for (i, node) in enumerate(followed_nodes)
        #push!(inbounds[i], n[node].inbound)
        push!(on_nodes[i], n[node].on_node)
        #push!(outbounds[i], n[node].outbound)
    end
end

#= positions = []
for node in followed_nodes
    push!(positions, (n[node].x, n[node].y))
end
fig = Figure(size = (1200, 800), resolution = (1200, 800))
range1 = 1:ceil(Int64, n_followed/2)
range2 = ceil(Int64, n_followed/2)+1:n_followed
ax1 = [Axis(fig[i, 1], title = "On_node "*string(positions[i])) for i in range1]
ax2 = [Axis(fig[i-ceil(Int64, n_followed/2), 2], title = "On_node "*string(positions[i])) for i in range2]
for i in 1:Int(length(followed_nodes)/2)
    lines!(ax1[i], on_nodes[range1[i]], color = :red)
    try lines!(ax2[i], on_nodes[range2[i]], color = :red)
    catch
    end   
    # lines!(axo[i], outbounds[i], color = :green)
end
#save("results/2-d sine wave.pdf", fig)
fig =#